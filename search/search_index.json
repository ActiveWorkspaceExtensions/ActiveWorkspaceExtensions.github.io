{
    "docs": [
        {
            "location": "/", 
            "text": "Declarative Extensions for Active Workspace\n\n\n\n\nEasy, High Performance, Maintainable, and Consistent Extensions\n\n\n\n\nReach New Efficiency Levels", 
            "title": "Home"
        }, 
        {
            "location": "/#declarative-extensions-for-active-workspace", 
            "text": "Easy, High Performance, Maintainable, and Consistent Extensions", 
            "title": "Declarative Extensions for Active Workspace"
        }, 
        {
            "location": "/#reach-new-efficiency-levels", 
            "text": "", 
            "title": "Reach New Efficiency Levels"
        }, 
        {
            "location": "/Getting-Started/Environment-Setup/Environment-Setup/", 
            "text": "Environment Setup\n\n\nVisual Studio Code\n\n\nTo Start out, we need a place to write code and use the command line. Don't worry. Visual Studio Code will make this much easier. Download \nVisual Studio Code\n. \n\n\n\n\nNode.js\n\n\nNode.js\n is a platform for building fast and scalable server applications using JavaScript. Node.js is the runtime and \nNPM\n is the Package Manager for Node.js modules.\n\n\nVisual Studio Code has support for the JavaScript and TypeScript languages out-of-the-box as well as Node.js debugging. However, to run a Node.js application, you will need to install the Node.js runtime on your machine.\n\n\nTo get started in this walkthrough, \ninstall Node.js for your platform\n. The Node Package Manager is included in the Node.js distribution. You'll need to open a new terminal (command prompt) for the \nnode\n and \nnpm\n command line tools to be on your PATH.\n\n\n\n\nNote\n\n\nLinux\n: There are specific Node.js packages available for the various flavors of Linux. See \nInstalling Node.js via package manager\n to find the Node.js package and installation instructions tailored to your version of Linux.\n\n\n\n\n\n\nTip\n\n\nTo test that you've got Node.js correctly installed on your computer, open a new terminal and type \nnode --help\n and you should see the usage documentation.\n\n\n\n\nNode.js Hello World\n\n\nEvery good tutorial starts off with a \"Hello World\" Example. Let's get started by creating the simplest Node.js application to get our feet wet with Visual Studio Code.\n\n\nCreate an empty folder called \"hello\", navigate into and open VS Code:\n\n\n1\n2\n3\nmkdir hello\n\ncd\n hello\ncode .\n\n\n\n\n\n\n\n\nTip\n\n\nYou can open files or folders directly from the command line.  The period '.' refers to the current folder, therefore VS Code will start and open the \nHello\n folder.\n\n\n\n\nFrom the File Explorer tool bar, press the New File button:\n\n\n\n\nand name the file \napp.js\n:\n\n\n\n\nBy using the \n.js\n file extension, VS Code interprets this file as JavaScript and will evaluate the contents with the JavaScript language service.\n\n\nCreate a simple string variable in \napp.js\n and send the contents of the string to the console:\n\n\n1\n2\nvar\n \nmsg\n \n=\n \nHello World\n;\n\n\nconsole\n.\nlog\n(\nmsg\n);\n\n\n\n\n\n\n\nNote that when you typed \nconsole.\n IntelliSense on the \nconsole\n object was automatically presented to you.\n\n\n\n\nAlso notice that VS Code knows that \nmsg\n is a string based on the initialization to \n'Hello World'\n.  If you type \nmsg.\n you'll see IntelliSense showing all of the string functions available on \nmsg\n.\n\n\n\n\nAfter experimenting with IntelliSense, revert any extra changes from the source code example above and save the file (\nkb(workbench.action.files.save)\n).\n\n\nRunning Hello World\n\n\nIt's simple to run \napp.js\n with Node.js. From a terminal, just type:\n\n\n1\nnode app.js\n\n\n\n\n\n\nYou should see \"Hello World\" output to the terminal and then Node.js returns.\n\n\nIntegrated Terminal\n\n\nVS Code has an \nintegrated terminal\n which you can use to run shell commands. You can run Node.js directly from there and avoid switching out of VS Code while running command line tools.\n\n\nView\n \n \nIntegrated Terminal\n (\nkb(workbench.action.terminal.toggleTerminal)\n with the backtick character) will open the integrated terminal and you can run \nnode app.js\n there:\n\n\n\n\nExpress.js\n\n\nExpress\n is a very popular application framework for building and running Node.js applications. You can scaffold (create) a new Express application using the Express Generator tool. The Express Generator is shipped as an NPM module and installed by using the NPM command line tool \nnpm\n. We use Express to create a local server run on your computer. This lets you view Active Workspace with your changes as you are working on it, before you put it in production.\n\n\n\n\nTip\n\n\nTo test that you've got \nnpm\n correctly installed on your computer, type \nnpm --help\n from a terminal and you should see the usage documentation.\n\n\n\n\nInstall the Express Generator by running the following from a terminal:\n\n\n1\nnpm install -g express-generator\n\n\n\n\n\n\nThe \n-g\n switch installs the Express Generator globally on your machine so you can run it from anywhere.\n\n\nJava 7 JDK 1.7.0_17\n\n\nWe need to download \nJava 7 JDK 1.7.0_17\n for the scripts to run.\n\n\n\n\nNow that we have that installed, we need to set our JAVA_HOME path, so the scripts know where it is.\n\n\n\n\nRight click My Computer and select Properties.\n\n\nOn the Advanced tab, select Environment Variables \n\n\nThen edit JAVA_HOME to point to where the JDK software is located, for example, C:\\Program Files\\Java\\1.7.0_17.\n\n\n\n\nIf you have any issues, Oracle has an article on \nInstalling the JDK Software and Setting JAVA_HOME\n\n\nSetting Up Source Code\n\n\nMake a Directory\n\n\nMake a new folder that will contain all of our code. I like having all of my projects in one folder on my root drive. For example \nC:\\dev\\MyProject\n. Place it at your liking. This can be done through the File Explorer or through the terminal. To make directories in command prompt:\n - Navigate to the directory to make a new folder.\n - \nmkdir newproject\n\n - \ncd newproject\n\n - \ncode .\n will open the project in VS Code \n\n\nActive Workspace Code\n\n\nNow we need the Active Workspace code inside of this project.\n\n\nGo to TC_ROOT/aws2/stage/src/out/war/assets\n/\n\n\nCopy the \nstage\n folder and paste into your New Project directory. I have found that due to the size of the folder, It helped to zip it up before copy and pasting. Then expand the zip in the folder. \n\n\nUpdate Proxy Server\n\n\nOpen the \nstage/build/express.js\n file in VS Code.\n\n\n\n\n\n\nChange the URLs to the TC Server. While we can run Active Workspace locally, we still need TeamCenter connected for all of the data.\n\n\nSet Up Express\n\n\ninside of the integrated terminal for your project we created earlier run the following commands:\n - \nrun\u00a0npm install express\n\n - \nnpm install http-proxy\n\n - \nnpm install\n\n\nYou may want to take a minute and grab a coffee. This will take a few minutes to install everything. This installs what we require for express to run.\n\n\nStart The Server\n\n\nOnce everything is completed, run \nexpress.cmd\n\n\n\n\nNow you have your own local Active Workspace deployment that you can play around with\u2026 To make changes on the fly utilize your custom modules and run \nwarRefresh.cmd\n from the terminal to see your changes automagically.", 
            "title": "Environment Setup"
        }, 
        {
            "location": "/Getting-Started/Environment-Setup/Environment-Setup/#environment-setup", 
            "text": "", 
            "title": "Environment Setup"
        }, 
        {
            "location": "/Getting-Started/Environment-Setup/Environment-Setup/#visual-studio-code", 
            "text": "To Start out, we need a place to write code and use the command line. Don't worry. Visual Studio Code will make this much easier. Download  Visual Studio Code .", 
            "title": "Visual Studio Code"
        }, 
        {
            "location": "/Getting-Started/Environment-Setup/Environment-Setup/#nodejs", 
            "text": "Node.js  is a platform for building fast and scalable server applications using JavaScript. Node.js is the runtime and  NPM  is the Package Manager for Node.js modules.  Visual Studio Code has support for the JavaScript and TypeScript languages out-of-the-box as well as Node.js debugging. However, to run a Node.js application, you will need to install the Node.js runtime on your machine.  To get started in this walkthrough,  install Node.js for your platform . The Node Package Manager is included in the Node.js distribution. You'll need to open a new terminal (command prompt) for the  node  and  npm  command line tools to be on your PATH.   Note  Linux : There are specific Node.js packages available for the various flavors of Linux. See  Installing Node.js via package manager  to find the Node.js package and installation instructions tailored to your version of Linux.    Tip  To test that you've got Node.js correctly installed on your computer, open a new terminal and type  node --help  and you should see the usage documentation.", 
            "title": "Node.js"
        }, 
        {
            "location": "/Getting-Started/Environment-Setup/Environment-Setup/#nodejs-hello-world", 
            "text": "Every good tutorial starts off with a \"Hello World\" Example. Let's get started by creating the simplest Node.js application to get our feet wet with Visual Studio Code.  Create an empty folder called \"hello\", navigate into and open VS Code:  1\n2\n3 mkdir hello cd  hello\ncode .    Tip  You can open files or folders directly from the command line.  The period '.' refers to the current folder, therefore VS Code will start and open the  Hello  folder.   From the File Explorer tool bar, press the New File button:   and name the file  app.js :   By using the  .js  file extension, VS Code interprets this file as JavaScript and will evaluate the contents with the JavaScript language service.  Create a simple string variable in  app.js  and send the contents of the string to the console:  1\n2 var   msg   =   Hello World ;  console . log ( msg );    Note that when you typed  console.  IntelliSense on the  console  object was automatically presented to you.   Also notice that VS Code knows that  msg  is a string based on the initialization to  'Hello World' .  If you type  msg.  you'll see IntelliSense showing all of the string functions available on  msg .   After experimenting with IntelliSense, revert any extra changes from the source code example above and save the file ( kb(workbench.action.files.save) ).", 
            "title": "Node.js Hello World"
        }, 
        {
            "location": "/Getting-Started/Environment-Setup/Environment-Setup/#running-hello-world", 
            "text": "It's simple to run  app.js  with Node.js. From a terminal, just type:  1 node app.js   You should see \"Hello World\" output to the terminal and then Node.js returns.", 
            "title": "Running Hello World"
        }, 
        {
            "location": "/Getting-Started/Environment-Setup/Environment-Setup/#integrated-terminal", 
            "text": "VS Code has an  integrated terminal  which you can use to run shell commands. You can run Node.js directly from there and avoid switching out of VS Code while running command line tools.  View     Integrated Terminal  ( kb(workbench.action.terminal.toggleTerminal)  with the backtick character) will open the integrated terminal and you can run  node app.js  there:", 
            "title": "Integrated Terminal"
        }, 
        {
            "location": "/Getting-Started/Environment-Setup/Environment-Setup/#expressjs", 
            "text": "Express  is a very popular application framework for building and running Node.js applications. You can scaffold (create) a new Express application using the Express Generator tool. The Express Generator is shipped as an NPM module and installed by using the NPM command line tool  npm . We use Express to create a local server run on your computer. This lets you view Active Workspace with your changes as you are working on it, before you put it in production.   Tip  To test that you've got  npm  correctly installed on your computer, type  npm --help  from a terminal and you should see the usage documentation.   Install the Express Generator by running the following from a terminal:  1 npm install -g express-generator   The  -g  switch installs the Express Generator globally on your machine so you can run it from anywhere.", 
            "title": "Express.js"
        }, 
        {
            "location": "/Getting-Started/Environment-Setup/Environment-Setup/#java-7-jdk-170_17", 
            "text": "We need to download  Java 7 JDK 1.7.0_17  for the scripts to run.   Now that we have that installed, we need to set our JAVA_HOME path, so the scripts know where it is.   Right click My Computer and select Properties.  On the Advanced tab, select Environment Variables   Then edit JAVA_HOME to point to where the JDK software is located, for example, C:\\Program Files\\Java\\1.7.0_17.   If you have any issues, Oracle has an article on  Installing the JDK Software and Setting JAVA_HOME", 
            "title": "Java 7 JDK 1.7.0_17"
        }, 
        {
            "location": "/Getting-Started/Environment-Setup/Environment-Setup/#setting-up-source-code", 
            "text": "", 
            "title": "Setting Up Source Code"
        }, 
        {
            "location": "/Getting-Started/Environment-Setup/Environment-Setup/#make-a-directory", 
            "text": "Make a new folder that will contain all of our code. I like having all of my projects in one folder on my root drive. For example  C:\\dev\\MyProject . Place it at your liking. This can be done through the File Explorer or through the terminal. To make directories in command prompt:\n - Navigate to the directory to make a new folder.\n -  mkdir newproject \n -  cd newproject \n -  code .  will open the project in VS Code", 
            "title": "Make a Directory"
        }, 
        {
            "location": "/Getting-Started/Environment-Setup/Environment-Setup/#active-workspace-code", 
            "text": "Now we need the Active Workspace code inside of this project.  Go to TC_ROOT/aws2/stage/src/out/war/assets /  Copy the  stage  folder and paste into your New Project directory. I have found that due to the size of the folder, It helped to zip it up before copy and pasting. Then expand the zip in the folder.", 
            "title": "Active Workspace Code"
        }, 
        {
            "location": "/Getting-Started/Environment-Setup/Environment-Setup/#update-proxy-server", 
            "text": "Open the  stage/build/express.js  file in VS Code.    Change the URLs to the TC Server. While we can run Active Workspace locally, we still need TeamCenter connected for all of the data.", 
            "title": "Update Proxy Server"
        }, 
        {
            "location": "/Getting-Started/Environment-Setup/Environment-Setup/#set-up-express", 
            "text": "inside of the integrated terminal for your project we created earlier run the following commands:\n -  run\u00a0npm install express \n -  npm install http-proxy \n -  npm install  You may want to take a minute and grab a coffee. This will take a few minutes to install everything. This installs what we require for express to run.", 
            "title": "Set Up Express"
        }, 
        {
            "location": "/Getting-Started/Environment-Setup/Environment-Setup/#start-the-server", 
            "text": "Once everything is completed, run  express.cmd   Now you have your own local Active Workspace deployment that you can play around with\u2026 To make changes on the fly utilize your custom modules and run  warRefresh.cmd  from the terminal to see your changes automagically.", 
            "title": "Start The Server"
        }, 
        {
            "location": "/Getting-Started/My-First-Extension/My-First-Extension/", 
            "text": "Note\n\n\nAW Version\n:  This tutorial is for Active Workspace version 4.0+ and may have some differences between the same steps in earlier versions.\n\n\n\n\nActive Workspace is a Teamcenter Client that utilizes web technologies like node.js, angularjs and others to meet the needs of many engineering, manufacturing and other systems around the world.  With these technologies na modern web development we can extend the Active Workspace to automate tasks on the client or display data a certain way.\n\n\nTo get started with this walkthrough make sure your \nenvironment is setup\n, and if you were able to have \nexpress running\n.\n\n\nThere are a few ways to create an extension within Active Workspace.  For this tutorial however we will go over the generator that comes with the client and how to generate a tools and info panel.\n\n\nInitialize the environment with initenv.cmd, this is located directly inside the Stage directory.  Next go ahead and type generateModule to see the list of modules you can create.\n\n\n\nGo ahead and for the type to generate type Command.  My command name is going to be HelloWorld. My Icon will by cmdCheckmark, the icon can be any icon included in the stage/src/images folder.  You can even put your own svg icons in there to use.\n\n\nCommand placement is where we will determine the anchor for this command.  Anchor is a good description for what this does.  Somewhere in our html we declare an anchor in a command bar, that anchor we can then use to display certain commands.  OOTB command anchors are those listed in the generateModule.\n\n\n\nLike said earlier in this tutorial we will use the aw_toolsAndInfo anchor which is the right side commands.  After typing aw_toolsAndInfo into the placement name it will generate HelloWorldViewModel.json, HelloWorldView.html inside of Stage/src under the new mysamplemodule directory.\n\n\n\n\nThe Definition of your new command is inside commandsViewModel.json under mysamplemodule.  The view and viewmodel are generated under the src directory.\n\n\nNow you can run a gwtcompile or warRefresh to compile the client and view your deployed changes with your new war file:", 
            "title": "My First Extension"
        }, 
        {
            "location": "/Documentation/What-is-Declarative/What-is-Declarative/", 
            "text": "Content Coming Soon", 
            "title": "What is Declarative"
        }, 
        {
            "location": "/Documentation/Examples/Location-Example/Location-Example/", 
            "text": "Content Coming Soon", 
            "title": "Location Example"
        }, 
        {
            "location": "/Extensions/HomeFolderLinkcmdGlobal/HomeFolderLinkcmdGlobal/", 
            "text": "HomeFolderLinkcmdGlobal Extension\n\n\nDownload the extension from GitHub \n\n\nWhat This Extension Does\n\n\n\n\nThis tutorial example is for Active Workspace 4.0\n\n\n\n\nThe global command bar in active workspace allows for generic links to be made that can help reduce clicks or input time to get to a certain location.\n\n\n\n\nThe HomeFolderLinkcmdGlobal extension does just this. Instead of having to click home then home folder, this module places a home folder command in the global toolbar. The command will take any user to their home folder, no matter where they are in the client.  \n\n\nHow to Use JavaScript and Services\n\n\nThe example also shows how to use JavaScript and services to get information required to build the url for the home folder. The home folder itself is just a URl constructed based upon the users home folder UID. The location is just a \nshowObject\n location. An example would be something like this:\n\n\n1\ncom\n.\nsiemens\n.\nsplm\n.\nclientfx\n.\ntcui\n.\nxrt\n.\nshowObject\n?\ns_uid\n=\ngofF7D0qqd$DyB\nuid\n=\ngofF7D0qqd$DyB\n\n\n\n\n\n\n\nThe first part, \ncom.siemens.splm.clientfx.tcui.xrt.showObject\n, is the location being used. This location needs a uid input to display whatever object needs to be displayed though. The UID for my home folder is the \ngofF7D0qqd$DyB\n. So how do we get that uid from the client? We need to use a service to find it.\n\n\nActions\n\n\nInside of the module.json you will find the actions associated with this command. The action \nactivateHomeFolderLinkcmdGlobal\n is actually a service being called from some javascript.\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\nactions\n:\n \n{\n\n            \nactivateHomeFolderLinkcmdGlobal\n:\n \n{\n\n                \nactionType\n:\n \nJSFunction\n,\n\n                \nmethod\n:\n \ngetProperties\n,\n\n                \ndeps\n:\n \nsoa/dataManagementService\n,\n\n                \ninputData\n:\n \n{\n\n                    \nuids\n:\n \n[\n\n                        \n{{ctx.user.uid}}\n\n                    \n],\n\n                    \npropNames\n:\n \n[\n\n                        \nhome_folder\n\n                    \n]\n\n                \n},\n\n                \noutputData\n:\n \n{\n\n                    \nctx.user\n:\n \n{{dataParseDefinitions:updateUserCtxForHomeFolder}}\n\n                \n},\n\n                \nevents\n:\n \n{\n\n                    \nsuccess\n:\n \n[{\n\n                        \nname\n:\n \nshowHomeFolderLink\n\n                    \n}]\n\n                \n}\n\n            \n},\n\n\n\n\n\n\n\nSo here we can see the action type as a \nJSFunction\n. This calls a JavaScript function from a certain file based on the two attributes, method and deps. \nMethod\n defines the method you want to use in the function. \nDeps\n defines the file you want to use. So this example specifically defines the method to be used as \ngetProperties\n in the file located in \nsoa/dataManagementService\n in your war file. (technically its within assets/js/soa/dataManagementService but it starts looking in the js folder initially).\n\n\n1\n2\n3\n4\n5\nactions\n:\n \n{\n\n            \nactivateHomeFolderLinkcmdGlobal\n:\n \n{\n\n                \nactionType\n:\n \nJSFunction\n,\n\n\n                \nmethod\n:\n \ngetProperties\n,\n\n\n                \ndeps\n:\n \nsoa/dataManagementService\n,\n\n\n\n\n\n\n\nSo now we know the method and the file its located in so we can find its inputs: \n\n\n1\nexports\n.\ngetProperties\n \n=\n \nfunction\n(\n \nuids\n,\n \npropNames\n \n)\n \n\n\n\n\nSo the inputs are \nuids\n and \npropNames\n for the uids.  We can provide that in the JSON as well:\n\n\n1\n2\n3\n4\n5\n6\n7\n8\ninputData\n:\n \n{\n\n                    \nuids\n:\n \n[\n\n                        \n{{ctx.user.uid}}\n\n                    \n],\n\n                    \npropNames\n:\n \n[\n\n                        \nhome_folder\n\n                    \n]\n\n                \n}\n,\n\n\n\n\n\n\n\nA reference type is a data type that refers to an object in memory. We know the home folder property is a typedReference on the user object. Getting the uid for that should be simple. The input for uids should be the user uid. We can get that through ctx just as we did above with ctx.user.uid.  We can easily see the ctx data if we run \nwindow._jsniInjector.service('appCtxService').ctx\n. The property on the user object we want is a typedReference which will return the UID of the typedReference object. On the User object that property is home_folder like above.\n\n\nNow that all of the inputs are solid we need to handle the output of the data, and put it in a position for easy access when we build the url for the link.\n\n\n1\n2\n3\noutputData\n:\n \n{\n\n                    \nctx.user\n:\n \n{{dataParseDefinitions:updateUserCtxForHomeFolder}}\n\n                \n}\n,\n\n\n\n\n\n\n\nData Parsing\n\n\nHere we are going to take the output of the method above and create our own \nctx.user.\nsomething\n that we can access when we click the link.  \n\n\n1\n2\n3\n4\n5\n6\n7\ndataParseDefinitions\n:\n \n{\n\n            \nupdateUserCtxForHomeFolder\n:\n \n{\n\n                \noutputFormatType\n:\n \nViewModelObject\n,\n\n                \ndataInput\n:\n \nplain[0]\n,\n\n                \noperationType\n:\n \nCREATE\n\n            \n}\n\n        \n}\n\n\n\n\n\n\n\nSo from above in outputData we defined a \ndataParseDefinition\n to call which is \nupdateUserCtxForHomeFolder\n. This \ndataParseDefinitions\n is taking the output format which will be a \nViewModelObject\n. We git this from the typedReference \nhome_folder\n property from the User object above. And, we are going to create that property under \nctx.user\n so we have access to it. The \ndataInput\n here is from the service return since we know there is only 1 object that should be returned here.  \n\n\nEvents\n\n\nWe now a have finished the service call, a success with our return, and updated a property on ctx.user. We now have access to the home folder UID. We can now make an event action to make the link. This event is just going to call an action \nshowHomeFolderLink\n:\n\n\n1\n2\n3\n4\nonEvent\n:\n \n[{\n\n            \neventId\n:\n \nshowHomeFolderLink\n,\n\n            \naction\n:\n \nshowHomeFolderLink\n\n        \n}]\n,\n\n\n\n\n\n\n\nThis event occurs from the initial action \nactivateHomeFolderLinkcmdGlobal\n success. As long as the service and the ctx.user update are successful, then we will call the event \nshowHomeFolderLink\n:\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\nshowHomeFolderLink\n:\n \n{\n\n                \nactionType\n:\n \nNavigate\n,\n\n                \nnavigateTo\n:\n \ncom_siemens_splm_clientfx_tcui_xrt_showObject\n,\n\n                \nnavigationParams\n:\n \n{\n\n                    \nuid\n:\n \n{{ctx.user.props.home_folder.dbValues[0]}}\n,\n\n                    \ncmdId\n:\n \n{{commandContext.cmdId}}\n,\n\n                    \ncmdArg\n:\n \n{{commandContext.cmdArgs}}\n\n                \n}\n\n            \n}\n\n\n\n\n\n\n\nIn AW 4.0 there is a new \nactionType\n. This actionType is called \nNavigate\n which can help replace any javascript code that generates and executes a URL in the same tab. The attributes are populated to determine where in AW you want to send the user. For this example we are going to send them to showObject location which is the \ncom_siemens_splm_clientfx_tcui_xrt_showObject\n above. There are parameters we can apply to this as well, since \nshowObject\n has a UID. From earlier we looked at how this is updating the \nctx.user\n props to allow us to use it later. This is where we use it.  The uid in \nnavigationParams\n can be set based on what we did earlier. \nctx.user.props.home_folder.dbValues[0]\n is now the uid of the users \nhome_folder\n which we need to generate the URL.  \ncmdID\n and \ncmdArg\n are used for tiles actually in the values you can generate there.  For this example we can ignore them.\n\n\nEnd Product\n\n\nIn the end here is what the final product does:", 
            "title": "HomeFolderLinkcmdGlobal"
        }, 
        {
            "location": "/Extensions/HomeFolderLinkcmdGlobal/HomeFolderLinkcmdGlobal/#homefolderlinkcmdglobal-extension", 
            "text": "Download the extension from GitHub", 
            "title": "HomeFolderLinkcmdGlobal Extension"
        }, 
        {
            "location": "/Extensions/HomeFolderLinkcmdGlobal/HomeFolderLinkcmdGlobal/#what-this-extension-does", 
            "text": "This tutorial example is for Active Workspace 4.0   The global command bar in active workspace allows for generic links to be made that can help reduce clicks or input time to get to a certain location.   The HomeFolderLinkcmdGlobal extension does just this. Instead of having to click home then home folder, this module places a home folder command in the global toolbar. The command will take any user to their home folder, no matter where they are in the client.", 
            "title": "What This Extension Does"
        }, 
        {
            "location": "/Extensions/HomeFolderLinkcmdGlobal/HomeFolderLinkcmdGlobal/#how-to-use-javascript-and-services", 
            "text": "The example also shows how to use JavaScript and services to get information required to build the url for the home folder. The home folder itself is just a URl constructed based upon the users home folder UID. The location is just a  showObject  location. An example would be something like this:  1 com . siemens . splm . clientfx . tcui . xrt . showObject ? s_uid = gofF7D0qqd$DyB uid = gofF7D0qqd$DyB    The first part,  com.siemens.splm.clientfx.tcui.xrt.showObject , is the location being used. This location needs a uid input to display whatever object needs to be displayed though. The UID for my home folder is the  gofF7D0qqd$DyB . So how do we get that uid from the client? We need to use a service to find it.", 
            "title": "How to Use JavaScript and Services"
        }, 
        {
            "location": "/Extensions/HomeFolderLinkcmdGlobal/HomeFolderLinkcmdGlobal/#actions", 
            "text": "Inside of the module.json you will find the actions associated with this command. The action  activateHomeFolderLinkcmdGlobal  is actually a service being called from some javascript.   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22 actions :   { \n             activateHomeFolderLinkcmdGlobal :   { \n                 actionType :   JSFunction , \n                 method :   getProperties , \n                 deps :   soa/dataManagementService , \n                 inputData :   { \n                     uids :   [ \n                         {{ctx.user.uid}} \n                     ], \n                     propNames :   [ \n                         home_folder \n                     ] \n                 }, \n                 outputData :   { \n                     ctx.user :   {{dataParseDefinitions:updateUserCtxForHomeFolder}} \n                 }, \n                 events :   { \n                     success :   [{ \n                         name :   showHomeFolderLink \n                     }] \n                 } \n             },    So here we can see the action type as a  JSFunction . This calls a JavaScript function from a certain file based on the two attributes, method and deps.  Method  defines the method you want to use in the function.  Deps  defines the file you want to use. So this example specifically defines the method to be used as  getProperties  in the file located in  soa/dataManagementService  in your war file. (technically its within assets/js/soa/dataManagementService but it starts looking in the js folder initially).  1\n2\n3\n4\n5 actions :   { \n             activateHomeFolderLinkcmdGlobal :   { \n                 actionType :   JSFunction ,                   method :   getProperties ,                   deps :   soa/dataManagementService ,    So now we know the method and the file its located in so we can find its inputs:   1 exports . getProperties   =   function (   uids ,   propNames   )    \nSo the inputs are  uids  and  propNames  for the uids.  We can provide that in the JSON as well:  1\n2\n3\n4\n5\n6\n7\n8 inputData :   { \n                     uids :   [ \n                         {{ctx.user.uid}} \n                     ], \n                     propNames :   [ \n                         home_folder \n                     ] \n                 } ,    A reference type is a data type that refers to an object in memory. We know the home folder property is a typedReference on the user object. Getting the uid for that should be simple. The input for uids should be the user uid. We can get that through ctx just as we did above with ctx.user.uid.  We can easily see the ctx data if we run  window._jsniInjector.service('appCtxService').ctx . The property on the user object we want is a typedReference which will return the UID of the typedReference object. On the User object that property is home_folder like above.  Now that all of the inputs are solid we need to handle the output of the data, and put it in a position for easy access when we build the url for the link.  1\n2\n3 outputData :   { \n                     ctx.user :   {{dataParseDefinitions:updateUserCtxForHomeFolder}} \n                 } ,", 
            "title": "Actions"
        }, 
        {
            "location": "/Extensions/HomeFolderLinkcmdGlobal/HomeFolderLinkcmdGlobal/#data-parsing", 
            "text": "Here we are going to take the output of the method above and create our own  ctx.user. something  that we can access when we click the link.    1\n2\n3\n4\n5\n6\n7 dataParseDefinitions :   { \n             updateUserCtxForHomeFolder :   { \n                 outputFormatType :   ViewModelObject , \n                 dataInput :   plain[0] , \n                 operationType :   CREATE \n             } \n         }    So from above in outputData we defined a  dataParseDefinition  to call which is  updateUserCtxForHomeFolder . This  dataParseDefinitions  is taking the output format which will be a  ViewModelObject . We git this from the typedReference  home_folder  property from the User object above. And, we are going to create that property under  ctx.user  so we have access to it. The  dataInput  here is from the service return since we know there is only 1 object that should be returned here.", 
            "title": "Data Parsing"
        }, 
        {
            "location": "/Extensions/HomeFolderLinkcmdGlobal/HomeFolderLinkcmdGlobal/#events", 
            "text": "We now a have finished the service call, a success with our return, and updated a property on ctx.user. We now have access to the home folder UID. We can now make an event action to make the link. This event is just going to call an action  showHomeFolderLink :  1\n2\n3\n4 onEvent :   [{ \n             eventId :   showHomeFolderLink , \n             action :   showHomeFolderLink \n         }] ,    This event occurs from the initial action  activateHomeFolderLinkcmdGlobal  success. As long as the service and the ctx.user update are successful, then we will call the event  showHomeFolderLink :  1\n2\n3\n4\n5\n6\n7\n8\n9 showHomeFolderLink :   { \n                 actionType :   Navigate , \n                 navigateTo :   com_siemens_splm_clientfx_tcui_xrt_showObject , \n                 navigationParams :   { \n                     uid :   {{ctx.user.props.home_folder.dbValues[0]}} , \n                     cmdId :   {{commandContext.cmdId}} , \n                     cmdArg :   {{commandContext.cmdArgs}} \n                 } \n             }    In AW 4.0 there is a new  actionType . This actionType is called  Navigate  which can help replace any javascript code that generates and executes a URL in the same tab. The attributes are populated to determine where in AW you want to send the user. For this example we are going to send them to showObject location which is the  com_siemens_splm_clientfx_tcui_xrt_showObject  above. There are parameters we can apply to this as well, since  showObject  has a UID. From earlier we looked at how this is updating the  ctx.user  props to allow us to use it later. This is where we use it.  The uid in  navigationParams  can be set based on what we did earlier.  ctx.user.props.home_folder.dbValues[0]  is now the uid of the users  home_folder  which we need to generate the URL.   cmdID  and  cmdArg  are used for tiles actually in the values you can generate there.  For this example we can ignore them.", 
            "title": "Events"
        }, 
        {
            "location": "/Extensions/HomeFolderLinkcmdGlobal/HomeFolderLinkcmdGlobal/#end-product", 
            "text": "In the end here is what the final product does:", 
            "title": "End Product"
        }, 
        {
            "location": "/Extensions/InboxLinkcmdGlobal/InboxLinkcmdGlobal/", 
            "text": "Content Coming Soon", 
            "title": "InboxLinkcmdGlobal"
        }, 
        {
            "location": "/Extensions/QuickLinksCmdPanel/QuickLinksCmdPanel/", 
            "text": "Content Coming Soon", 
            "title": "QuickLinksCmdPanel"
        }, 
        {
            "location": "/Extensions/at4Create/at4Create/", 
            "text": "Content Coming Soon", 
            "title": "at4Create"
        }
    ]
}